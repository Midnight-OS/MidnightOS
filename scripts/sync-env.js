#!/usr/bin/env node

/**
 * Environment Sync Script for MidnightOS
 * 
 * This script syncs environment variables from the root .env file
 * to all service-specific .env files based on their requirements.
 * 
 * Usage: node scripts/sync-env.js [--check]
 * Options:
 *   --check    Dry run - shows what would be updated without making changes
 *   --verbose  Show detailed output
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

// Parse command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--check');
const isVerbose = args.includes('--verbose');

// Helper functions
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

function verbose(message) {
  if (isVerbose) {
    log(`  ${colors.dim}${message}${colors.reset}`);
  }
}

function error(message) {
  log(`❌ ${message}`, colors.red);
}

function success(message) {
  log(`✅ ${message}`, colors.green);
}

function info(message) {
  log(`ℹ️  ${message}`, colors.blue);
}

function warning(message) {
  log(`⚠️  ${message}`, colors.yellow);
}

// Parse .env file into key-value pairs
function parseEnvFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return {};
  }
  
  const content = fs.readFileSync(filePath, 'utf8');
  const env = {};
  
  content.split('\n').forEach(line => {
    // Skip comments and empty lines
    if (line.trim().startsWith('#') || !line.trim()) {
      return;
    }
    
    // Handle key=value pairs (including multiline values)
    const match = line.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/);
    if (match) {
      const key = match[1];
      let value = match[2];
      
      // Remove surrounding quotes if present
      if ((value.startsWith('"') && value.endsWith('"')) || 
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }
      
      env[key] = value;
    }
  });
  
  return env;
}

// Write env object to file
function writeEnvFile(filePath, env, append = false) {
  const lines = [];
  
  // Add header comment
  if (!append) {
    lines.push('# Auto-generated by sync-env.js');
    lines.push(`# Last updated: ${new Date().toISOString()}`);
    lines.push('# DO NOT EDIT DIRECTLY - Edit root .env and run pnpm sync:env');
    lines.push('');
  }
  
  // Write each key-value pair
  Object.entries(env).forEach(([key, value]) => {
    // Add quotes if value contains spaces or special characters
    if (value && (value.includes(' ') || value.includes('\n') || value.includes('#'))) {
      value = `"${value}"`;
    }
    lines.push(`${key}=${value}`);
  });
  
  const content = lines.join('\n') + '\n';
  
  if (isDryRun) {
    info(`Would write to ${filePath}:`);
    console.log(content);
  } else {
    // Create directory if it doesn't exist
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    if (append) {
      fs.appendFileSync(filePath, '\n' + content);
    } else {
      fs.writeFileSync(filePath, content);
    }
  }
}

// Environment variable mapping for each service
const SERVICE_ENV_MAPPING = {
  // Platform Orchestrator
  'platform/orchestrator/.env': {
    required: ['JWT_SECRET', 'NODE_ENV'],
    optional: ['DATABASE_URL', 'OPENAI_API_KEY', 'ANTHROPIC_API_KEY'],
    defaults: {
      PORT: '3002',
      NODE_ENV: 'development',
    },
    transform: (rootEnv) => ({
      // Use DATABASE_URL (PostgreSQL) if provided, otherwise fallback to SQLite
      DATABASE_URL: rootEnv.DATABASE_URL || `file:${rootEnv.DATABASE_PATH || './data/midnightos.db'}`,
      DIRECT_URL: rootEnv.DIRECT_URL || rootEnv.DATABASE_URL || '',
      POSTGRES_URL: rootEnv.POSTGRES_URL || rootEnv.DATABASE_URL || '',
      POSTGRES_USER: rootEnv.POSTGRES_USER || 'postgres',
      POSTGRES_HOST: rootEnv.POSTGRES_HOST || 'localhost',
      POSTGRES_PASSWORD: rootEnv.POSTGRES_PASSWORD || '',
      POSTGRES_DATABASE: rootEnv.POSTGRES_DATABASE || 'postgres',
      SUPABASE_URL: rootEnv.SUPABASE_URL || 'https://yuherkwaayoegfjhhjhz.supabase.co',
      SUPABASE_JWT_SECRET: rootEnv.SUPABASE_JWT_SECRET || '',
      SUPABASE_SERVICE_ROLE_KEY: rootEnv.SUPABASE_SERVICE_ROLE_KEY || '',
      JWT_SECRET: rootEnv.JWT_SECRET || 'change-this-in-production',
      NODE_ENV: rootEnv.NODE_ENV || 'development',
      PORT: rootEnv.ORCHESTRATOR_PORT || '3002',
      OPENAI_API_KEY: rootEnv.OPENAI_API_KEY || '',
      ANTHROPIC_API_KEY: rootEnv.ANTHROPIC_API_KEY || '',
    })
  },
  
  // Frontend
  'platform/frontend/.env': {
    required: [],
    optional: ['SUPABASE_URL', 'SUPABASE_ANON_KEY'],
    defaults: {
      NEXT_PUBLIC_API_URL: 'http://localhost:3002/api',
      NEXT_PUBLIC_APP_URL: 'http://localhost:3003',
    },
    transform: (rootEnv) => ({
      NEXT_PUBLIC_API_URL: rootEnv.NEXT_PUBLIC_API_URL || rootEnv.ORCHESTRATOR_URL || 'http://localhost:3002/api',
      NEXT_PUBLIC_APP_URL: rootEnv.NEXT_PUBLIC_APP_URL || rootEnv.FRONTEND_URL || 'http://localhost:3003',
      NEXT_PUBLIC_SUPABASE_URL: rootEnv.NEXT_PUBLIC_SUPABASE_URL || rootEnv.SUPABASE_URL || 'https://yuherkwaayoegfjhhjhz.supabase.co',
      NEXT_PUBLIC_SUPABASE_ANON_KEY: rootEnv.NEXT_PUBLIC_SUPABASE_ANON_KEY || rootEnv.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl1aGVya3dhYXlvZWdmamhoamh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwNzA2NzYsImV4cCI6MjA3NDY0NjY3Nn0.YdBnNWNyyPwNN1l0cy7EpR70jvslw_4Mac1ju-Owtcs',
    })
  },
  
  // Eliza Agent Service
  'services/eliza-agent/.env': {
    required: ['OPENAI_API_KEY'],
    optional: ['ANTHROPIC_API_KEY', 'DISCORD_TOKEN', 'TELEGRAM_BOT_TOKEN'],
    defaults: {
      AGENT_ID: 'midnight-bot-agent-local',
      WALLET_MCP_URL: 'http://localhost:3001',
      MODEL_TYPE: 'openai',
      LOG_LEVEL: 'info',
      PGLITE_DATA_DIR: '.eliza/.elizadb',
    },
    transform: (rootEnv) => ({
      AGENT_ID: rootEnv.AGENT_ID || 'midnight-bot-agent-local',
      WALLET_MCP_URL: rootEnv.WALLET_MCP_URL || 'http://localhost:3001',
      MODEL_TYPE: rootEnv.MODEL_TYPE || 'openai',
      OPENAI_API_KEY: rootEnv.OPENAI_API_KEY,
      ANTHROPIC_API_KEY: rootEnv.ANTHROPIC_API_KEY || '',
      DATABASE_URL: rootEnv.DATABASE_URL || '',
      LOG_LEVEL: rootEnv.LOG_LEVEL || 'info',
      PGLITE_DATA_DIR: '.eliza/.elizadb',
      // Social platforms (optional)
      DISCORD_TOKEN: rootEnv.DISCORD_TOKEN || '',
      DISCORD_SERVER_ID: rootEnv.DISCORD_SERVER_ID || '',
      TELEGRAM_BOT_TOKEN: rootEnv.TELEGRAM_BOT_TOKEN || '',
      // Blockchain (optional)
      EVM_PRIVATE_KEY: rootEnv.EVM_PRIVATE_KEY || '',
      EVM_PROVIDER_URL: rootEnv.EVM_PROVIDER_URL || '',
      SOLANA_PRIVATE_KEY: rootEnv.SOLANA_PRIVATE_KEY || '',
      SOLANA_PUBLIC_KEY: rootEnv.SOLANA_PUBLIC_KEY || '',
      // Features
      ENABLE_IMAGE_GENERATION: rootEnv.ENABLE_IMAGE_GENERATION || 'false',
      ENABLE_NFT_GENERATION: rootEnv.ENABLE_NFT_GENERATION || 'false',
    })
  },
  
  // Midnight MCP Service
  'services/midnight-mcp/.env': {
    required: [],
    optional: ['DATABASE_URL'],
    defaults: {
      NODE_ENV: 'development',
      PORT: '3001',
      USE_EXTERNAL_PROOF_SERVER: 'true',
    },
    transform: (rootEnv) => ({
      // Use the Prisma Accelerate URL or fallback to SQLite
      DATABASE_URL: rootEnv.DATABASE_URL,
      DIRECT_URL: rootEnv.DIRECT_URL,
      PORT: rootEnv.MCP_PORT || '3001',
      AGENT_ID: rootEnv.AGENT_ID || 'agent-001',
      USE_EXTERNAL_PROOF_SERVER: rootEnv.USE_EXTERNAL_PROOF_SERVER || 'true',
      PROOF_SERVER: rootEnv.PROOF_SERVER || 'http://localhost:6300',
      INDEXER: rootEnv.INDEXER || 'https://indexer.testnet-02.midnight.network/api/v1/graphql',
      INDEXER_WS: rootEnv.INDEXER_WS || 'wss://indexer.testnet-02.midnight.network/api/v1/graphql/ws',
      MN_NODE: rootEnv.MN_NODE || 'https://rpc.testnet-02.midnight.network',
    })
  },
  
  // Docker environment (for docker-compose)
  'docker/.env': {
    required: [],
    optional: ['OPENAI_API_KEY', 'ANTHROPIC_API_KEY', 'DATABASE_URL', 'JWT_SECRET'],
    defaults: {},
    transform: (rootEnv) => ({
      // Core configuration
      NODE_ENV: rootEnv.NODE_ENV || 'production',
      
      // Database
      DATABASE_URL: rootEnv.DATABASE_URL,
      
      // Authentication
      JWT_SECRET: rootEnv.JWT_SECRET || 'change-this-in-production',
      
      // AI Configuration
      OPENAI_API_KEY: rootEnv.OPENAI_API_KEY || '',
      ANTHROPIC_API_KEY: rootEnv.ANTHROPIC_API_KEY || '',
      
      // Midnight Network
      NETWORK_ID: rootEnv.NETWORK_ID || 'TestNet',
      USE_EXTERNAL_PROOF_SERVER: rootEnv.USE_EXTERNAL_PROOF_SERVER || 'true',
      PROOF_SERVER: rootEnv.PROOF_SERVER || 'https://rpc-proof-devnet.midnight.network:8443',
      INDEXER: rootEnv.INDEXER || 'https://indexer.testnet-02.midnight.network/api/v1/graphql',
      INDEXER_WS: rootEnv.INDEXER_WS || 'wss://indexer.testnet-02.midnight.network/api/v1/graphql/ws',
      MN_NODE: rootEnv.MN_NODE || 'https://rpc.testnet-02.midnight.network',
      
      // Supabase (optional)
      SUPABASE_URL: rootEnv.SUPABASE_URL || 'https://yuherkwaayoegfjhhjhz.supabase.co',
      NEXT_PUBLIC_SUPABASE_ANON_KEY: rootEnv.NEXT_PUBLIC_SUPABASE_ANON_KEY || rootEnv.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl1aGVya3dhYXlvZWdmamhoamh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwNzA2NzYsImV4cCI6MjA3NDY0NjY3Nn0.YdBnNWNyyPwNN1l0cy7EpR70jvslw_4Mac1ju-Owtcs',
      
      // Logging
      LOG_LEVEL: rootEnv.LOG_LEVEL || 'info',
    })
  }
};

// Main sync function
function syncEnvironments() {
  const rootEnvPath = path.join(__dirname, '..', '.env');
  
  // Check if root .env exists
  if (!fs.existsSync(rootEnvPath)) {
    error('Root .env file not found!');
    info('Please create a .env file in the root directory first.');
    process.exit(1);
  }
  
  // Parse root .env
  const rootEnv = parseEnvFile(rootEnvPath);
  success(`Loaded ${Object.keys(rootEnv).length} variables from root .env`);
  
  if (isVerbose) {
    verbose('Root environment variables:');
    Object.keys(rootEnv).forEach(key => {
      const value = rootEnv[key];
      const displayValue = key.includes('KEY') || key.includes('SECRET') || key.includes('PASSWORD')
        ? '***' + value.slice(-4)
        : value.slice(0, 20) + (value.length > 20 ? '...' : '');
      verbose(`  ${key}=${displayValue}`);
    });
  }
  
  // Track statistics
  let updatedCount = 0;
  let errorCount = 0;
  const missingRequired = [];
  
  // Sync to each service
  Object.entries(SERVICE_ENV_MAPPING).forEach(([servicePath, config]) => {
    const fullPath = path.join(__dirname, '..', servicePath);
    
    info(`\nProcessing ${servicePath}...`);
    
    // Check required variables
    const missing = config.required.filter(key => !rootEnv[key]);
    if (missing.length > 0) {
      warning(`Missing required variables: ${missing.join(', ')}`);
      missingRequired.push({ service: servicePath, missing });
    }
    
    // Transform variables for this service
    const serviceEnv = config.transform(rootEnv);
    
    // Check if file exists and compare
    const existingEnv = parseEnvFile(fullPath);
    const changes = [];
    
    Object.entries(serviceEnv).forEach(([key, value]) => {
      if (existingEnv[key] !== value) {
        changes.push(key);
      }
    });
    
    if (changes.length > 0) {
      verbose(`  Changes detected: ${changes.join(', ')}`);
      writeEnvFile(fullPath, serviceEnv);
      updatedCount++;
      success(`  Updated ${fullPath} (${changes.length} changes)`);
    } else {
      verbose('  No changes needed');
    }
  });
  
  // Create .env.local files if they don't exist
  const localEnvFiles = [
    'platform/frontend/.env.local',
    'services/eliza-agent/.env.local',
  ];
  
  localEnvFiles.forEach(localPath => {
    const fullPath = path.join(__dirname, '..', localPath);
    if (!fs.existsSync(fullPath) && !isDryRun) {
      fs.writeFileSync(fullPath, '# Local overrides (not committed to git)\n');
      verbose(`Created ${localPath}`);
    }
  });
  
  // Summary
  console.log('\n' + '='.repeat(60));
  if (isDryRun) {
    info('DRY RUN COMPLETE - No files were modified');
  } else {
    success(`Environment sync complete!`);
  }
  
  info(`Services updated: ${updatedCount}/${Object.keys(SERVICE_ENV_MAPPING).length}`);
  
  if (missingRequired.length > 0) {
    warning('\nMissing required variables:');
    missingRequired.forEach(({ service, missing }) => {
      console.log(`  ${service}: ${missing.join(', ')}`);
    });
    warning('\nAdd these to your root .env file and run sync again.');
  }
  
  // Check for unused variables
  const usedKeys = new Set();
  Object.values(SERVICE_ENV_MAPPING).forEach(config => {
    Object.keys(config.transform(rootEnv)).forEach(key => {
      // Track which root env keys are actually used
      if (rootEnv[key]) usedKeys.add(key);
    });
  });
  
  const unusedKeys = Object.keys(rootEnv).filter(key => !usedKeys.has(key));
  if (unusedKeys.length > 0 && isVerbose) {
    warning('\nUnused root environment variables:');
    unusedKeys.forEach(key => {
      verbose(`  ${key}`);
    });
  }
}

// Add validation function
function validateEnvironments() {
  const rootEnvPath = path.join(__dirname, '..', '.env');
  const rootEnv = parseEnvFile(rootEnvPath);
  
  console.log('\n' + colors.bright + 'Environment Validation Report' + colors.reset);
  console.log('='.repeat(60));
  
  // Check each service
  Object.entries(SERVICE_ENV_MAPPING).forEach(([servicePath, config]) => {
    console.log(`\n${colors.cyan}${servicePath}${colors.reset}`);
    
    // Check required
    config.required.forEach(key => {
      if (rootEnv[key]) {
        console.log(`  ✅ ${key}: Set`);
      } else {
        console.log(`  ❌ ${key}: Missing (REQUIRED)`);
      }
    });
    
    // Check optional
    config.optional.forEach(key => {
      if (rootEnv[key]) {
        console.log(`  ✅ ${key}: Set`);
      } else {
        console.log(`  ⚪ ${key}: Not set (optional)`);
      }
    });
  });
  
  // Check API key validity
  console.log('\n' + colors.bright + 'API Key Validation:' + colors.reset);
  
  if (rootEnv.OPENAI_API_KEY) {
    if (rootEnv.OPENAI_API_KEY.startsWith('sk-')) {
      success('  OpenAI API Key format looks valid');
    } else {
      warning('  OpenAI API Key format may be invalid (should start with sk-)');
    }
  }
  
  if (rootEnv.DATABASE_URL) {
    if (rootEnv.DATABASE_URL.includes('://')) {
      success('  Database URL format looks valid');
    } else {
      warning('  Database URL format may be invalid');
    }
  }
}

// Run based on command
if (args.includes('--validate')) {
  validateEnvironments();
} else {
  syncEnvironments();
}